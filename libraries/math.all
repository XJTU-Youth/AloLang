%lib math
__CPP__
{
#include<cmath>
}
%def PI    3.141592653589793
%def SQRT2 1.414213562373095
%def SQRT3 1.730508075688772
%def SQRT5 2.236067977499789
%def _E    2.718281828459045
%def LN2   0.693147180559945
%def LN10  2.302585092994045
%def LN3   1.098612288668109
%def LG2   0.301029995663981
%def LG3   0.477121254719662
%def LG5   0.698970004336018
const double ERR=1e-9;
fun gcd(long a,long b)->long
{
    if(a<b){long c=a;a=b;b=c;}
    if(a%b==0) return b;
    return gcd(a%b,b);
}
fun lcm(long a,long b)->long
{
    return a*b/gcd(a,b); 
}
fun q_pow(long a,long n,long mod)->long
{
    long ans=1;
    while(n>0)
    {
     if(n%2==1) ans=ans*a%mod;
     a=a*a%mod;
     n/=2;
    }
    return ans;
}
fun isprime(long a)->bool
{
    if(a<2) return false;
    if(a==2||a==3) return true;
    if(a%6!=1&&a%6!=5) return false;
    int i=5;
    while(i*i<=a)
    {
     if(a%i==0) return false;
     i+=6;
    }
    return true;
}
fun abs(long a)->long
{
    if(a>=0) return a;
    else return -a;
}
fun dabs(double a)->double
{
    if(a>=0) return a;
    else return -a;
}
fun round(double a)->int
{
    if(a>0)return int(a+0.5);
    else return int(a-0.5);
}
fun beint(double a)->int
{
    if(dabs(int(a)-a)<ERR) return true;
    else return false;
}
fun floor(double a)->int
{
    if(beint(a)==true) return a;
    if(a<0) return int(a)-1;
    return int(a); 
}
fun ceil(double a)->int
{
    if(beint(a)==true) return a;
    else return floor(a)+1;
}
fun lpow(long a,long b)->long
{
    long ans=1;
    while(b>0)
    {
     if(b%2==1) ans=ans*a;
     a=a*a;
     b/=2;
    }
    return ans;
}
fun dpow(double a,double b)->double
{
    __CPP__
    {
       double c;
       c=pow(a,b);
       return c;
    }
}
fun ln(double a)->double
{
    __CPP__
    {
        return log(a);
    }
}
fun lg(double a)->double
{
    __CPP__
   {
       return log10(a);
   }
}
fun log(double a,double x)->double//aÊÇµ×Êý
{
    return ln(x)/ln(a);
}
fun exp(double a)->double
{
    __CPP__
    {
        return exp(a);
    }
}
fun deg(double x)->double
{
    return x*180/PI;
}
fun rad(double x)->double
{
    return x*PI/180;
}
#ifndef _GLIBCXX_COMPLEX
#ifndef _COMPLEX_H_
#define _ALO_COMPLEX
__CPP__
{
  // Forward declarations
  template<typename _Tp> class complex;
  template<> class complex<float>;
  template<> class complex<double>;
  template<> class complex<long double>;

  ///  Return magnitude of @a z.
  template<typename _Tp> _Tp abs(const complex<_Tp>&);
  ///  Return phase angle of @a z.
  template<typename _Tp> _Tp arg(const complex<_Tp>&);
  ///  Return @a z magnitude squared.
  template<typename _Tp> _Tp norm(const complex<_Tp>&);

  ///  Return complex conjugate of @a z.
  template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);
  ///  Return complex with magnitude @a rho and angle @a theta.
  template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp& = 0);

  // Transcendentals:
  /// Return complex cosine of @a z.
  template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);
  /// Return complex hyperbolic cosine of @a z.
  template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);
  /// Return complex base e exponential of @a z.
  template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);
  /// Return complex natural logarithm of @a z.
  template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);
  /// Return complex base 10 logarithm of @a z.
  template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);
  /// Return complex cosine of @a z.
  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);
  /// Return @a x to the @a y'th power.
  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);
  /// Return @a x to the @a y'th power.
  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, 
					   const complex<_Tp>&);
  /// Return @a x to the @a y'th power.
  template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);
  /// Return complex sine of @a z.
  template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);
  /// Return complex hyperbolic sine of @a z.
  template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);
  /// Return complex square root of @a z.
  template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);
  /// Return complex tangent of @a z.
  template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);
  /// Return complex hyperbolic tangent of @a z.
  template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);
  //@}
  template<typename _Tp>
    class complex
    {
    public:

      typedef _Tp value_type;
      complex(const _Tp& = _Tp(), const _Tp & = _Tp());
      template<typename _Up>
        complex(const complex<_Up>&);
      _Tp& real(); 
      const _Tp& real() const;
      ///  Return imaginary part of complex number.
      _Tp& imag();
      ///  Return imaginary part of complex number.
      const _Tp& imag() const;

      /// Assign this complex number to scalar @a t.
      complex<_Tp>& operator=(const _Tp&);
      /// Add @a t to this complex number.
      complex<_Tp>& operator+=(const _Tp&);
      /// Subtract @a t from this complex number.
      complex<_Tp>& operator-=(const _Tp&);
      /// Multiply this complex number by @a t.
      complex<_Tp>& operator*=(const _Tp&);
      /// Divide this complex number by @a t.
      complex<_Tp>& operator/=(const _Tp&);

      // Lets the compiler synthesize the
      // copy and assignment operator
      // complex<_Tp>& operator= (const complex<_Tp>&);
      /// Assign this complex number to complex @a z.
      template<typename _Up>
        complex<_Tp>& operator=(const complex<_Up>&);
      /// Add @a z to this complex number.
      template<typename _Up>
        complex<_Tp>& operator+=(const complex<_Up>&);
      /// Subtract @a z from this complex number.
      template<typename _Up>
        complex<_Tp>& operator-=(const complex<_Up>&);
      /// Multiply this complex number by @a z.
      template<typename _Up>
        complex<_Tp>& operator*=(const complex<_Up>&);
      /// Divide this complex number by @a z.
      template<typename _Up>
        complex<_Tp>& operator/=(const complex<_Up>&);

    private:
      _Tp _M_real;
      _Tp _M_imag;
    };

  template<typename _Tp>
    inline _Tp&
    complex<_Tp>::real() { return _M_real; }

  template<typename _Tp>
    inline const _Tp&
    complex<_Tp>::real() const { return _M_real; }

  template<typename _Tp>
    inline _Tp&
    complex<_Tp>::imag() { return _M_imag; }

  template<typename _Tp>
    inline const _Tp&
    complex<_Tp>::imag() const { return _M_imag; }

  template<typename _Tp>
    inline 
    complex<_Tp>::complex(const _Tp& __r, const _Tp& __i)
    : _M_real(__r), _M_imag(__i) { }

  template<typename _Tp>
    template<typename _Up>
    inline 
    complex<_Tp>::complex(const complex<_Up>& __z)
    : _M_real(__z.real()), _M_imag(__z.imag()) { }
        
  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator=(const _Tp& __t)
    {
     _M_real = __t;
     _M_imag = _Tp();
     return *this;
    } 

  // 26.2.5/1
  template<typename _Tp>
    inline complex<_Tp>&
    complex<_Tp>::operator+=(const _Tp& __t)
    {
      _M_real += __t;
      return *this;
    }

  // 26.2.5/3
  template<typename _Tp>
    inline complex<_Tp>&
    complex<_Tp>::operator-=(const _Tp& __t)
    {
      _M_real -= __t;
      return *this;
    }

  // 26.2.5/5
  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator*=(const _Tp& __t)
    {
      _M_real *= __t;
      _M_imag *= __t;
      return *this;
    }

  // 26.2.5/7
  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator/=(const _Tp& __t)
    {
      _M_real /= __t;
      _M_imag /= __t;
      return *this;
    }

  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator=(const complex<_Up>& __z)
    {
      _M_real = __z.real();
      _M_imag = __z.imag();
      return *this;
    }

  // 26.2.5/9
  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator+=(const complex<_Up>& __z)
    {
      _M_real += __z.real();
      _M_imag += __z.imag();
      return *this;
    }

  // 26.2.5/11
  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator-=(const complex<_Up>& __z)
    {
      _M_real -= __z.real();
      _M_imag -= __z.imag();
      return *this;
    }

  // 26.2.5/13
  // XXX: This is a grammar school implementation.
  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator*=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
      _M_real = __r;
      return *this;
    }

  // 26.2.5/15
  // XXX: This is a grammar school implementation.
  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator/=(const complex<_Up>& __z)
    {
      const _Tp __r =  _M_real * __z.real() + _M_imag * __z.imag();
      const _Tp __n = std::norm(__z);
      _M_imag = (_M_imag * __z.real() - _M_real * __z.imag()) / __n;
      _M_real = __r / __n;
      return *this;
    }
    
  // Operators:
  //@{
  ///  Return new complex value @a x plus @a y.
  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r.real() += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r.real() += __x;
      return __r;
    }
  //@}

  //@{
  ///  Return new complex value @a x minus @a y.
  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }
    
  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r.real() -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r(__x, -__y.imag());
      __r.real() -= __y.real();
      return __r;
    }
  //@}

  //@{
  ///  Return new complex value @a x times @a y.
  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r *= __x;
      return __r;
    }
  //@}

  //@{
  ///  Return new complex value @a x divided by @a y.
  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }
    
  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }
  //@}

  ///  Return @a x.
  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x)
    { return __x; }

  ///  Return complex negation of @a x.
  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x)
    {  return complex<_Tp>(-__x.real(), -__x.imag()); }

  //@{
  ///  Return true if @a x is equal to @a y.
  template<typename _Tp>
    inline bool
    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }

  template<typename _Tp>
    inline bool
    operator==(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() == __y && __x.imag() == _Tp(); }

  template<typename _Tp>
    inline bool
    operator==(const _Tp& __x, const complex<_Tp>& __y)
    { return __x == __y.real() && _Tp() == __y.imag(); }
  //@}

  //@{
  ///  Return false if @a x is equal to @a y.
  template<typename _Tp>
    inline bool
    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }

  template<typename _Tp>
    inline bool
    operator!=(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() != __y || __x.imag() != _Tp(); }

  template<typename _Tp>
    inline bool
    operator!=(const _Tp& __x, const complex<_Tp>& __y)
    { return __x != __y.real() || _Tp() != __y.imag(); }
  //@}

  ///  Extraction operator for complex values.
  template<typename _Tp, typename _CharT, class _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)
    {
      _Tp __re_x, __im_x;
      _CharT __ch;
      __is >> __ch;
      if (__ch == '(') 
	{
	  __is >> __re_x >> __ch;
	  if (__ch == ',') 
	    {
	      __is >> __im_x >> __ch;
	      if (__ch == ')') 
		__x = complex<_Tp>(__re_x, __im_x);
	      else
		__is.setstate(ios_base::failbit);
	    }
	  else if (__ch == ')') 
	    __x = __re_x;
	  else
	    __is.setstate(ios_base::failbit);
	}
      else 
	{
	  __is.putback(__ch);
	  __is >> __re_x;
	  __x = __re_x;
	}
      return __is;
    }

  ///  Insertion operator for complex values.
  template<typename _Tp, typename _CharT, class _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
    {
      basic_ostringstream<_CharT, _Traits> __s;
      __s.flags(__os.flags());
      __s.imbue(__os.getloc());
      __s.precision(__os.precision());
      __s << '(' << __x.real() << ',' << __x.imag() << ')';
      return __os << __s.str();
    }

  // Values
  template<typename _Tp>
    inline _Tp&
    real(complex<_Tp>& __z)
    { return __z.real(); }
    
  template<typename _Tp>
    inline const _Tp&
    real(const complex<_Tp>& __z)
    { return __z.real(); }
    
  template<typename _Tp>
    inline _Tp&
    imag(complex<_Tp>& __z)
    { return __z.imag(); }
    
  template<typename _Tp>
    inline const _Tp&
    imag(const complex<_Tp>& __z)
    { return __z.imag(); }

  template<typename _Tp>
    inline _Tp
    abs(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();
      const _Tp __s = std::max(abs(__x), abs(__y));
      if (__s == _Tp())  // well ...
        return __s;
      __x /= __s; 
      __y /= __s;
      return __s * sqrt(__x * __x + __y * __y);
    }

  template<typename _Tp>
    inline _Tp
    arg(const complex<_Tp>& __z)
    { return atan2(__z.imag(), __z.real()); }

  // 26.2.7/5: norm(__z) returns the squared magintude of __z.
  //     As defined, norm() is -not- a norm is the common mathematical
  //     sens used in numerics.  The helper class _Norm_helper<> tries to
  //     distinguish between builtin floating point and the rest, so as
  //     to deliver an answer as close as possible to the real value.
  template<bool>
    struct _Norm_helper
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          const _Tp __x = __z.real();
          const _Tp __y = __z.imag();
          return __x * __x + __y * __y;
        }
    };

  template<>
    struct _Norm_helper<true>
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          _Tp __res = std::abs(__z);
          return __res * __res;
        }
    };
  
  template<typename _Tp>
    inline _Tp
    norm(const complex<_Tp>& __z)
    {
      return _Norm_helper<__is_floating<_Tp>::_M_type && !_GLIBCXX_FAST_MATH>::_S_do_it(__z);
    }

  template<typename _Tp>
    inline complex<_Tp>
    polar(const _Tp& __rho, const _Tp& __theta)
    { return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta)); }

  template<typename _Tp>
    inline complex<_Tp>
    conj(const complex<_Tp>& __z)
    { return complex<_Tp>(__z.real(), -__z.imag()); }
  
  // Transcendentals
  template<typename _Tp>
    inline complex<_Tp>
    cos(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));
    }

  template<typename _Tp>
    inline complex<_Tp>
    cosh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));
    }

  template<typename _Tp>
    inline complex<_Tp>
    exp(const complex<_Tp>& __z)
    { return std::polar(exp(__z.real()), __z.imag()); }

  template<typename _Tp>
    inline complex<_Tp>
    log(const complex<_Tp>& __z)
    { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }

  template<typename _Tp>
    inline complex<_Tp>
    log10(const complex<_Tp>& __z)
    { return std::log(__z) / log(_Tp(10.0)); }

  template<typename _Tp>
    inline complex<_Tp>
    sin(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y)); 
    }

  template<typename _Tp>
    inline complex<_Tp>
    sinh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp  __y = __z.imag();
      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));
    }

  template<typename _Tp>
    complex<_Tp>
    sqrt(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();

      if (__x == _Tp())
        {
          _Tp __t = sqrt(abs(__y) / 2);
          return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);
        }
      else
        {
          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));
          _Tp __u = __t / 2;
          return __x > _Tp()
            ? complex<_Tp>(__u, __y / __t)
            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);
        }
    }

  template<typename _Tp>
    inline complex<_Tp>
    tan(const complex<_Tp>& __z)
    {
      return std::sin(__z) / std::cos(__z);
    }

  template<typename _Tp>
    inline complex<_Tp>
    tanh(const complex<_Tp>& __z)
    {
      return std::sinh(__z) / std::cosh(__z);
    }

  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __z, int __n)
    {
      return std::__pow_helper(__z, __n);
    }

  template<typename _Tp>
    complex<_Tp>
    pow(const complex<_Tp>& __x, const _Tp& __y)
    {
      if (__x.imag() == _Tp() && __x.real() > _Tp())
        return pow(__x.real(), __y);

      complex<_Tp> __t = std::log(__x);
      return std::polar(exp(__y * __t.real()), __y * __t.imag());
    }

  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x));
    }

  template<typename _Tp>
    inline complex<_Tp>
    pow(const _Tp& __x, const complex<_Tp>& __y)
    {
      return __x > _Tp() ? std::polar(pow(__x, __y.real()),
				      __y.imag() * log(__x))
	                 : std::pow(complex<_Tp>(__x, _Tp()), __y);
    }

  // 26.2.3  complex specializations
  // complex<float> specialization
  template<> class complex<float>
  {
  public:
    typedef float value_type;
    
    complex(float = 0.0f, float = 0.0f);
#ifdef _GLIBCXX_BUGGY_COMPLEX
    complex(const complex& __z) : _M_value(__z._M_value) { }
#endif
    explicit complex(const complex<double>&);
    explicit complex(const complex<long double>&);

    float& real();
    const float& real() const;
    float& imag();
    const float& imag() const;

    complex<float>& operator=(float);
    complex<float>& operator+=(float);
    complex<float>& operator-=(float);
    complex<float>& operator*=(float);
    complex<float>& operator/=(float);
        
    // Let's the compiler synthetize the copy and assignment
    // operator.  It always does a pretty good job.
    // complex& operator= (const complex&);
    template<typename _Tp>
      complex<float>&operator=(const complex<_Tp>&);
    template<typename _Tp>
      complex<float>& operator+=(const complex<_Tp>&);
    template<class _Tp>
      complex<float>& operator-=(const complex<_Tp>&);
    template<class _Tp>
      complex<float>& operator*=(const complex<_Tp>&);
    template<class _Tp>
      complex<float>&operator/=(const complex<_Tp>&);

  private:
    typedef __complex__ float _ComplexT;
    _ComplexT _M_value;

    complex(_ComplexT __z) : _M_value(__z) { }
        
    friend class complex<double>;
    friend class complex<long double>;
  };

  inline float&
  complex<float>::real()
  { return __real__ _M_value; }

  inline const float&
  complex<float>::real() const
  { return __real__ _M_value; }

  inline float&
  complex<float>::imag()
  { return __imag__ _M_value; }

  inline const float&
  complex<float>::imag() const
  { return __imag__ _M_value; }

  inline
  complex<float>::complex(float r, float i)
  {
    __real__ _M_value = r;
    __imag__ _M_value = i;
  }

  inline complex<float>&
  complex<float>::operator=(float __f)
  {
    __real__ _M_value = __f;
    __imag__ _M_value = 0.0f;
    return *this;
  }

  inline complex<float>&
  complex<float>::operator+=(float __f)
  {
    __real__ _M_value += __f;
    return *this;
  }

  inline complex<float>&
  complex<float>::operator-=(float __f)
  {
    __real__ _M_value -= __f;
    return *this;
  }

  inline complex<float>&
  complex<float>::operator*=(float __f)
  {
    _M_value *= __f;
    return *this;
  }

  inline complex<float>&
  complex<float>::operator/=(float __f)
  {
    _M_value /= __f;
    return *this;
  }

  template<typename _Tp>
  inline complex<float>&
  complex<float>::operator=(const complex<_Tp>& __z)
  {
    __real__ _M_value = __z.real();
    __imag__ _M_value = __z.imag();
    return *this;
  }

  template<typename _Tp>
  inline complex<float>&
  complex<float>::operator+=(const complex<_Tp>& __z)
  {
    __real__ _M_value += __z.real();
    __imag__ _M_value += __z.imag();
    return *this;
  }
    
  template<typename _Tp>
    inline complex<float>&
    complex<float>::operator-=(const complex<_Tp>& __z)
    {
     __real__ _M_value -= __z.real();
     __imag__ _M_value -= __z.imag();
     return *this;
    } 

  template<typename _Tp>
    inline complex<float>&
    complex<float>::operator*=(const complex<_Tp>& __z)
    {
      _ComplexT __t;
      __real__ __t = __z.real();
      __imag__ __t = __z.imag();
      _M_value *= __t;
      return *this;
    }

  template<typename _Tp>
    inline complex<float>&
    complex<float>::operator/=(const complex<_Tp>& __z)
    {
      _ComplexT __t;
      __real__ __t = __z.real();
      __imag__ __t = __z.imag();
      _M_value /= __t;
      return *this;
    }

  // 26.2.3  complex specializations
  // complex<double> specialization
  template<> class complex<double>
  {
  public:
    typedef double value_type;

    complex(double  =0.0, double =0.0);
#ifdef _GLIBCXX_BUGGY_COMPLEX
    complex(const complex& __z) : _M_value(__z._M_value) { }
#endif
    complex(const complex<float>&);
    explicit complex(const complex<long double>&);

    double& real();
    const double& real() const;
    double& imag();
    const double& imag() const;
        
    complex<double>& operator=(double);
    complex<double>& operator+=(double);
    complex<double>& operator-=(double);
    complex<double>& operator*=(double);
    complex<double>& operator/=(double);

    // The compiler will synthetize this, efficiently.
    // complex& operator= (const complex&);
    template<typename _Tp>
      complex<double>& operator=(const complex<_Tp>&);
    template<typename _Tp>
      complex<double>& operator+=(const complex<_Tp>&);
    template<typename _Tp>
      complex<double>& operator-=(const complex<_Tp>&);
    template<typename _Tp>
      complex<double>& operator*=(const complex<_Tp>&);
    template<typename _Tp>
      complex<double>& operator/=(const complex<_Tp>&);

  private:
    typedef __complex__ double _ComplexT;
    _ComplexT _M_value;

    complex(_ComplexT __z) : _M_value(__z) { }
        
    friend class complex<float>;
    friend class complex<long double>;
  };

  inline double&
  complex<double>::real()
  { return __real__ _M_value; }

  inline const double&
  complex<double>::real() const
  { return __real__ _M_value; }

  inline double&
  complex<double>::imag()
  { return __imag__ _M_value; }

  inline const double&
  complex<double>::imag() const
  { return __imag__ _M_value; }

  inline
  complex<double>::complex(double __r, double __i)
  {
    __real__ _M_value = __r;
    __imag__ _M_value = __i;
  }

  inline complex<double>&
  complex<double>::operator=(double __d)
  {
    __real__ _M_value = __d;
    __imag__ _M_value = 0.0;
    return *this;
  }

  inline complex<double>&
  complex<double>::operator+=(double __d)
  {
    __real__ _M_value += __d;
    return *this;
  }

  inline complex<double>&
  complex<double>::operator-=(double __d)
  {
    __real__ _M_value -= __d;
    return *this;
  }

  inline complex<double>&
  complex<double>::operator*=(double __d)
  {
    _M_value *= __d;
    return *this;
  }

  inline complex<double>&
  complex<double>::operator/=(double __d)
  {
    _M_value /= __d;
    return *this;
  }

  template<typename _Tp>
    inline complex<double>&
    complex<double>::operator=(const complex<_Tp>& __z)
    {
      __real__ _M_value = __z.real();
      __imag__ _M_value = __z.imag();
      return *this;
    }
    
  template<typename _Tp>
    inline complex<double>&
    complex<double>::operator+=(const complex<_Tp>& __z)
    {
      __real__ _M_value += __z.real();
      __imag__ _M_value += __z.imag();
      return *this;
    }

  template<typename _Tp>
    inline complex<double>&
    complex<double>::operator-=(const complex<_Tp>& __z)
    {
      __real__ _M_value -= __z.real();
      __imag__ _M_value -= __z.imag();
      return *this;
    }

  template<typename _Tp>
    inline complex<double>&
    complex<double>::operator*=(const complex<_Tp>& __z)
    {
      _ComplexT __t;
      __real__ __t = __z.real();
      __imag__ __t = __z.imag();
      _M_value *= __t;
      return *this;
    }

  template<typename _Tp>
    inline complex<double>&
    complex<double>::operator/=(const complex<_Tp>& __z)
    {
      _ComplexT __t;
      __real__ __t = __z.real();
      __imag__ __t = __z.imag();
      _M_value /= __t;
      return *this;
    }

  // 26.2.3  complex specializations
  // complex<long double> specialization
  template<> class complex<long double>
  {
  public:
    typedef long double value_type;

    complex(long double = 0.0L, long double = 0.0L);
#ifdef _GLIBCXX_BUGGY_COMPLEX
    complex(const complex& __z) : _M_value(__z._M_value) { }
#endif
    complex(const complex<float>&);
    complex(const complex<double>&);

    long double& real();
    const long double& real() const;
    long double& imag();
    const long double& imag() const;

    complex<long double>& operator= (long double);
    complex<long double>& operator+= (long double);
    complex<long double>& operator-= (long double);
    complex<long double>& operator*= (long double);
    complex<long double>& operator/= (long double);

    // The compiler knows how to do this efficiently
    // complex& operator= (const complex&);
    template<typename _Tp>
      complex<long double>& operator=(const complex<_Tp>&);
    template<typename _Tp>
      complex<long double>& operator+=(const complex<_Tp>&);
    template<typename _Tp>
      complex<long double>& operator-=(const complex<_Tp>&);
    template<typename _Tp>
      complex<long double>& operator*=(const complex<_Tp>&);
    template<typename _Tp>
      complex<long double>& operator/=(const complex<_Tp>&);

  private:
    typedef __complex__ long double _ComplexT;
    _ComplexT _M_value;

    complex(_ComplexT __z) : _M_value(__z) { }

    friend class complex<float>;
    friend class complex<double>;
  };

  inline
  complex<long double>::complex(long double __r, long double __i)
  {
    __real__ _M_value = __r;
    __imag__ _M_value = __i;
  }

  inline long double&
  complex<long double>::real()
  { return __real__ _M_value; }

  inline const long double&
  complex<long double>::real() const
  { return __real__ _M_value; }

  inline long double&
  complex<long double>::imag()
  { return __imag__ _M_value; }

  inline const long double&
  complex<long double>::imag() const
  { return __imag__ _M_value; }

  inline complex<long double>&   
  complex<long double>::operator=(long double __r)
  {
    __real__ _M_value = __r;
    __imag__ _M_value = 0.0L;
    return *this;
  }

  inline complex<long double>&
  complex<long double>::operator+=(long double __r)
  {
    __real__ _M_value += __r;
    return *this;
  }

  inline complex<long double>&
  complex<long double>::operator-=(long double __r)
  {
    __real__ _M_value -= __r;
    return *this;
  }

  inline complex<long double>&
  complex<long double>::operator*=(long double __r)
  {
    _M_value *= __r;
    return *this;
  }

  inline complex<long double>&
  complex<long double>::operator/=(long double __r)
  {
    _M_value /= __r;
    return *this;
  }

  template<typename _Tp>
    inline complex<long double>&
    complex<long double>::operator=(const complex<_Tp>& __z)
    {
      __real__ _M_value = __z.real();
      __imag__ _M_value = __z.imag();
      return *this;
    }

  template<typename _Tp>
    inline complex<long double>&
    complex<long double>::operator+=(const complex<_Tp>& __z)
    {
      __real__ _M_value += __z.real();
      __imag__ _M_value += __z.imag();
      return *this;
    }

  template<typename _Tp>
    inline complex<long double>&
    complex<long double>::operator-=(const complex<_Tp>& __z)
    {
      __real__ _M_value -= __z.real();
      __imag__ _M_value -= __z.imag();
      return *this;
    }
    
  template<typename _Tp>
    inline complex<long double>&
    complex<long double>::operator*=(const complex<_Tp>& __z)
    {
      _ComplexT __t;
      __real__ __t = __z.real();
      __imag__ __t = __z.imag();
      _M_value *= __t;
      return *this;
    }

  template<typename _Tp>
    inline complex<long double>&
    complex<long double>::operator/=(const complex<_Tp>& __z)
    {
      _ComplexT __t;
      __real__ __t = __z.real();
      __imag__ __t = __z.imag();
      _M_value /= __t;
      return *this;
    }

  // These bits have to be at the end of this file, so that the
  // specializations have all been defined.
  // ??? No, they have to be there because of compiler limitation at
  // inlining.  It suffices that class specializations be defined.
  inline
  complex<float>::complex(const complex<double>& __z)
  : _M_value(_ComplexT(__z._M_value)) { }

  inline
  complex<float>::complex(const complex<long double>& __z)
  : _M_value(_ComplexT(__z._M_value)) { }

  inline
  complex<double>::complex(const complex<float>& __z) 
  : _M_value(_ComplexT(__z._M_value)) { }

  inline
  complex<double>::complex(const complex<long double>& __z)
  {
    __real__ _M_value = __z.real();
    __imag__ _M_value = __z.imag();
  }

  inline
  complex<long double>::complex(const complex<float>& __z)
  : _M_value(_ComplexT(__z._M_value)) { }

  inline
  complex<long double>::complex(const complex<double>& __z)
  : _M_value(_ComplexT(__z._M_value)) { }
}
#endif
#endif
fun solve_cubic(double a,double b,double c,double d)->complex,complex,complex//ax^3+bx^2+cx+d=0
{
   complex<double> x1,x2,x3;
   double A=b*b-3*a*c,B=b*c-9*b*d,C=c*c-3*b*d;
   double delta=B*B-4*A*C;
   if(delta<=0)
   {
     double t,si;
     t=(2*A*b-3*a*B)/(2*sqrt(A*A*A));
     si=arccos(t);
     x1=(-b-2*sqrt(as)*cos(si/3))/(3*a);
     x2=(-b+sqrt(as)*(cos(si/3)+sqrt(3)*sin(si/3)))/(3*a);
     x3=(-b+sqrt(as)*(cos(si/3)-sqrt(3)*sin(si/3)))/(3*a);
   }
   else
   {
       double Y1=A*b+3/2*a*(-B+sqrt(delta));
       double Y2=A*b+3/2*a*(-B-sqrt(delta));
       x1=(-b-(dpow(Y1,1/3)+dpow(Y2,1/3)))/3a;
       x2.real((-b+0.5*(dpow(Y1,1/3)+dpow(Y2,1/3)))/3a);
       x2.imag(0.5*SQRT3*(dpow(Y1,1/3)-dpow(Y2,1/3)));
       x3.real((-b+0.5*(dpow(Y1,1/3)+dpow(Y2,1/3)))/3a);
       x3.imag(-0.5*SQRT3*(dpow(Y1,1/3)-dpow(Y2,1/3)));
   }
//need a return here!!!
}