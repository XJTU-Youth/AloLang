%lib math
__CPP__
{
#include<cmath>
#include<complex>
using namespace std;
}
%def PI    3.141592653589793
%def SQRT2 1.414213562373095
%def SQRT3 1.730508075688772
%def SQRT5 2.236067977499789
%def _E    2.718281828459045
%def LN2   0.693147180559945
%def LN10  2.302585092994045
%def LN3   1.098612288668109
%def LG2   0.301029995663981
%def LG3   0.477121254719662
%def LG5   0.698970004336018
const double ERR=1e-9;
fun gcd(long a,long b)->long
{
    if(a<b){long c=a;a=b;b=c;}
    if(a%b==0) return b;
    return gcd(a%b,b);
}
fun lcm(long a,long b)->long
{
    return a*b/gcd(a,b); 
}
fun q_pow(long a,long n,long mod)->long
{
    long ans=1;
    while(n>0)
    {
     if(n%2==1) ans=ans*a%mod;
     a=a*a%mod;
     n/=2;
    }
    return ans;
}
fun isprime(long a)->bool
{
    if(a<2) return false;
    if(a==2||a==3) return true;
    if(a%6!=1&&a%6!=5) return false;
    int i=5;
    while(i*i<=a)
    {
     if(a%i==0) return false;
     i+=6;
    }
    return true;
}
fun abs(long a)->long
{
    if(a>=0) return a;
    else return -a;
}
fun dabs(double a)->double
{
    if(a>=0) return a;
    else return -a;
}
fun round(double a)->int
{
    if(a>0)return int(a+0.5);
    else return int(a-0.5);
}
fun beint(double a)->int
{
    if(dabs(int(a)-a)<ERR) return true;
    else return false;
}
fun floor(double a)->int
{
    if(beint(a)==true) return a;
    if(a<0) return int(a)-1;
    return int(a); 
}
fun ceil(double a)->int
{
    if(beint(a)==true) return a;
    else return floor(a)+1;
}
fun lpow(long a,long b)->long
{
    long ans=1;
    while(b>0)
    {
     if(b%2==1) ans=ans*a;
     a=a*a;
     b/=2;
    }
    return ans;
}
fun dpow(double a,double b)->double
{
    __CPP__
    {
       double c;
       c=pow(a,b);
       return c;
    }
}
fun ln(double a)->double
{
    __CPP__
    {
        return log(a);
    }
}
fun lg(double a)->double
{
    __CPP__
   {
       return log10(a);
   }
}
fun log(double a,double x)->double//aÊÇµ×Êý
{
    return ln(x)/ln(a);
}
fun exp(double a)->double
{
    __CPP__
    {
        return exp(a);
    }
}
fun deg(double x)->double
{
    return x*180/PI;
}
fun rad(double x)->double
{
    return x*PI/180;
}

fun solve_cubic(double a,double b,double c,double d)->complex,complex,complex//ax^3+bx^2+cx+d=0
{
   complex<double> x1,x2,x3;
   double A=b*b-3*a*c,B=b*c-9*b*d,C=c*c-3*b*d;
   double delta=B*B-4*A*C;
   if(delta<=0)
   {
     double t,si;
     t=(2*A*b-3*a*B)/(2*sqrt(A*A*A));
     si=arccos(t);
     x1=(-b-2*sqrt(as)*cos(si/3))/(3*a);
     x2=(-b+sqrt(as)*(cos(si/3)+sqrt(3)*sin(si/3)))/(3*a);
     x3=(-b+sqrt(as)*(cos(si/3)-sqrt(3)*sin(si/3)))/(3*a);
   }
   else
   {
       double Y1=A*b+3/2*a*(-B+sqrt(delta));
       double Y2=A*b+3/2*a*(-B-sqrt(delta));
       x1=(-b-(dpow(Y1,1/3)+dpow(Y2,1/3)))/3a;
       x2.real((-b+0.5*(dpow(Y1,1/3)+dpow(Y2,1/3)))/3a);
       x2.imag(0.5*SQRT3*(dpow(Y1,1/3)-dpow(Y2,1/3)));
       x3.real((-b+0.5*(dpow(Y1,1/3)+dpow(Y2,1/3)))/3a);
       x3.imag(-0.5*SQRT3*(dpow(Y1,1/3)-dpow(Y2,1/3)));
   }
//need a return here!!!
}