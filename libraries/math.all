%lib math
%def PI    3.141592653589793
%def SQRT2 1.414213562373095
%def SQRT3 1.730508075688772
%def SQRT5 2.236067977499789
%def _E    2.718281828459045
%def LN2   0.693147180559945
%def LN10  2.302585092994045
%def LN3   1.098612288668109
%def LG2   0.301029995663981
%def LG3   0.477121254719662
%def LG5   0.698970004336018
struct complex
{
    double r;
    double i;
}
const double ERR=1e-9;
fun gcd(long a,long b)->long
{
    if(a<b){long c=a;a=b;b=c;}
    if(a%b==0) return b;
    return gcd(a%b,b);
}
fun lcm(long a,long b)->long
{
    return a*b/gcd(a,b); 
}
fun q_pow(long a,long n,long mod)->long
{
    long ans=1;
    while(n>0)
    {
     if(n%2==1) ans=ans*a%mod;
     a=a*a%mod;
     n/=2;
    }
    return ans;
}
fun isprime(long a)->bool
{
    if(a<2) return false;
    if(a==2||a==3) return true;
    if(a%6!=1&&a%6!=5) return false;
    int i=5;
    while(i*i<=a)
    {
     if(a%i==0) return false;
     i+=6;
    }
    return true;
}
fun abs(long a)->long
{
    if(a>=0) return a;
    else return -a;
}
fun dabs(double a)->double
{
    if(a>=0) return a;
    else return -a;
}
fun round(double a)->int
{
    if(a>0)return int(a+0.5);
    else return int(a-0.5);
}
fun beint(double a)->int
{
    if(dabs(int(a)-a)<ERR) return true;
    else return false;
}
fun floor(double a)->int
{
    if(beint(a)==true) return a;
    if(a<0) return int(a)-1;
    return int(a); 
}
fun ceil(double a)->int
{
    if(beint(a)==true) return a;
    else return floor(a)+1;
}
fun lpow(long a,long b)->long
{
    long ans=1;
    while(b>0)
    {
     if(b%2==1) ans=ans*a;
     a=a*a;
     b/=2;
    }
    return ans;
}
fun dpow(double a,double b)->double
{
    //todo
}