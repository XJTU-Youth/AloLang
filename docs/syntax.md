# Alolang语言参考

## 词法约定

本节介绍 Alolang 程序的基本元素。 你将使用这些名为“词法元素”或“标记”的元素构造用于构造完整程序的语句、定义和声明等。 本节将讨论以下词法元素：

### 标记和字符集

程序的文本由标记和空格组成。 C++ 标记是对编译器有用的 C++ 程序的最小元素。 C++分析器识别以下类型的标记：

-关键字
-标识符
-数值、布尔和指针文本
-字符串和字符文本
-用户定义的文本
-运算符
-标点符号

标记通常由空格分隔，可以是一个或多个：

-空白
-水平或垂直制表符
-新行
-换源
-Comments

#### 基本源字符集

C++标准指定可用于源文件的基本源字符集。 若要表示这组字符之外的字符，可以通过使用通用字符名称指定其他字符。 MSVC 实现允许其他字符。 基本源字符集由可在源文件中使用的96个字符组成。 这组字符包括空白字符、水平制表符、垂直制表符、换页符和换行控制字符以及这一组图形字符：

```Alolang

a b c d e f g h i j k l m n o p q r s t u v w x y z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

0 1 2 3 4 5 6 7 8 9

_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " '

```

#### 通用字符名称

由于 Alolang 程序可使用的字符要比在基本源字符集中指定的字符要多得多，所以可以通过使用 通用字符名称以可移植的方式指定这些字符。 通用字符名称由表示 Unicode 码位的字符序列组成。 采用两种形式。 使用 \UNNNNNNNN 表示形式为 U+NNNNNNNN 的 Unicode 码位，其中 NNNNNNNN 是八位的十六进制码位数字。 使用四位的 \uNNNN 表示形式为 U+0000NNNN 的 Unicode 码位。

通用字符名称可用于标识符、字符串和字符文本中。 通用字符名称不能用于表示范围 0xD800-0xDFFF 之内的代理项码位。 而应使用所需的码位；编译器会自动生成任何必需的代理项。 其他限制适用于可在标识符中使用的通用字符名称。 有关详细信息，请参阅 Identifiers 和 String and Character Literals。\

#### 执行字符集

执行字符集表示可以出现在编译的程序中的字符和字符串。 这些字符集包含源文件中允许的所有字符，还包含表示警报、backspace、回车符和 null 字符的控制字符。 执行字符集具有特定于区域设置的表示形式。

### 注释

注释是编译器忽略但对于程序员非常有用的文本。 注释通常用于批注代码以供将来参考。 编译器会将它们视为空白。 您可以使用测试中的注释来使某些代码行处于非活动状态;但是，#if/#endif 预处理器指令的工作效果更好，因为你可以包围包含注释的代码，但不能嵌套注释。

通过以下方式之一是编写 Alolang 注释：

/* （斜杠，星号）字符，后跟任何字符序列（包括新行），后跟 */ 个字符。

// （两个斜杠）字符，后跟任何字符序列。 不紧跟在反斜杠之前的新行会终止这种形式的注释。 因此，它通常称为 "单行注释"。

注释字符（`/*`、`*/`和`//`）在字符常量、字符串文本或注释中没有特殊含义。 使用第一个语法的注释无法嵌套。

### 标识符

标识符是用于表示以下内容之一的字符序列：

-对象或变量名称
-类、结构或联合名称
-枚举类型名称
-类、结构、联合或枚举的成员
-函数或类成员函数
-typedef 名称
-标签名称
-宏名称
-宏参数

允许将以下字符用作标识符的任意字符：

``` alolang
_ a b c d e f g h i j k l m
n o p q r s t u v w x y z
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z
```

允许将以下字符用作标识符中除第一个字符以外的任意字符：

``` alolang
0 1 2 3 4 5 6 7 8 9
```

标识符的第一个字符必须是字母字符（大写、小写或带下划线 ( _ ) 的字母）。 由于 Alolang 标识符区分大小写，因此 fileName 与 FileName不同。

标识符不能与关键字有完全相同的拼写和大小写。 包含关键字的标识符是合法的。 例如，Pint是一个合法标识符，即使它包含int，这是一个关键字。

使用两个顺序下划线字符 ( __ ) 在一个标识符或在单个前导下划线后跟一个大写字母，将保留用于C++中的所有作用域的实现。 由于当前或将来的保留标识符可能发生冲突，因此应避免对文件范围的名称使用一个前导下划线后跟小写字母。

### 关键字

关键字是具有特殊意义的预定义保留标识符。 它们不能用作程序中的标识符。

Alolang 保留了下列关键字。

``` alolang
begin    bool
break    case    catch    char    const    delete    continue    do    double    else    enum    end
extern    false    finally    float    for    friend    goto    if    inline    int    long    new
operator    sizeof    static    struct    switch    template    this    throw    true    try    typedef
typeid    typename    union    virtual    void    volatile    while    __cpp__
```

### 标点符号

在 Alolang 中，标点符号相对于编译器来说具有语法意义和语义含义，但是它们本身不会指定一个产生数值的操作。 某些标点符号（单独或组合）也可以是 Alolang 运算符或对预处理器很重要。
以下任意字符都被视为标点符号：

``` alolang
! % ^ & * ( ) - + = { } | ~
[ ] \ ; ' : " < > ? , . / #
```

标点符号 [] 、 （） 和 {} 必须成对出现。

### 数值、布尔文本

文本是一种直接表示值的程序元素。文本的最常用法是初始化命名变量以及将自变量传递给函数。

有时需要指示编译器如何解释某个文本或者为其赋予哪种特定类型。 你可以通过为文本追加前缀或后缀来达到此目的。 例如，前缀 0x 指示编译器将其后面的数字解释为十六进制值，例如 0x35。 U) 后缀通知编译器将值视为无符号长整型类型，如5894345ULL 中所示。 有关每个文本类型的前缀和后缀的完整列表，请参阅以下各节。

#### 整数文本

整数文本以数字开头，没有小数部分或指数。 你可以指定十进制、八进制或十六进制形式的整数文本。 它们可指定有符号类型或无符号类型以及长类型或短类型。
如果不存在前缀或后缀，则编译器将提供整型文本值类型int （64位）（如果值适合），否则它会将其类型指定为长整型（任意位）。

要指定十进制整型文本，请以非零数字作为规范的开头。要指定八进制整型文本，请以 0 作为规范的开头，后跟 0 到 7 之间的一系列数字。 在指定八进制文本时，使用数字 8 和 9 是错误做法。 要指定十六进制整型文本，请以 0x 或 0X 作为规范的开头（“x”的大小写形式并不重要），后跟 0 到 9 以及 a（或 A）到 f（或 F）之间的一系列数字。 十六进制数字 a（或 A）到 f（或 F）表示介于 10 和 15 之间的值。若要指定 long 类型，请使用 l 或 L 后缀。

数字分隔符：可以使用单引号字符（撇号）将位置值隔开，使其更易于阅读。 分隔符不会对编译产生任何影响。

#### 浮点文本

浮点文本指定必须具有小数部分的值。 这些值包含小数点（ . ），并且可包含指数。

浮点文本具有“尾数”（用于指定数字的值）、“指数”（用于指定数字的量级）和可选的后缀（用于指定文本的类型）。 指定的尾数的格式是一系列位数后跟一个句点，再后跟表示数字的小数部分的可选的一系列位数。

指数（如果有）指定数字的量级为 10 次幂，如以下示例所示：

指数可以使用 e 或 E来指定，它们具有相同的含义，后跟一个可选符号（+ 或-）和一系列数字。 如果指数存在，则整数（如 18E0）中不需要尾随的小数点。
浮点文本默认为double类型。

#### 布尔值文本

布尔值文本为true和false。

### 字符串和字符文本

#### 字符串文本

由一个或几个字符常量构成。 它由用双引号引起来的字符串表示。

#### 字符文本

由一个字符常量构成。 它由用单引号引起来的字符表示。用于字符文本的字符可以是除保留字符反斜杠（"\"）、单引号（'）或换行符之外的任何字符。 可以使用转义序列指定保留字符。 可以通过使用通用字符名称指定字符，只要类型的大小足以保留字符。

##### 编码

字符文本根据其前缀以不同的方式进行编码。

不带前缀的字符文本是普通字符文本。 包含可在执行字符集中表示的单个字符、转义序列或通用字符名称的普通字符文本值具有等于其编码在执行字符集中的数值的值。 包含多个字符、转义序列或通用字符名称的普通字符文本是一个多字符文本。 不能用执行字符集表示的多字符文本或普通字符文本的类型为int，其值是实现定义的。 有关 MSVC，请参阅下面的Microsoft 特定部分。

以 L 前缀开头的字符文本是宽字符文本。 包含单个字符、转义序列或通用字符名称的宽字符文本的值的值等于其在执行宽字符集中的编码的数值，除非字符文本在执行宽字符集，在这种情况下，该值是实现定义的。 包含多个字符、转义序列或通用字符名称的宽字符文本的值是实现定义的。 有关 MSVC，请参阅下面的Microsoft 特定部分。

以 u8 前缀开头的字符文本是 UTF-8 字符文本。 如果 UTF-8 字符文本包含一个字符、转义序列或通用字符名称，则其值等于其 ISO 10646 码位值（如果可由单个 UTF-8 代码单元表示（对应于 C0 控件和基本拉丁语）Unicode 块）。 如果值不能由单个 UTF-8 代码单元表示，则程序格式不正确。 包含多个字符、转义序列或通用字符名称的 UTF-8 字符文本格式错误。

以 u 前缀开头的字符文本是 UTF-16 字符文本。 如果 UTF-16 字符文本包含一个字符、转义序列或通用字符名称，则其值等于其 ISO 10646 码位值（如果它可由单个 UTF-16 代码单元表示（对应于基本多语言平面）). 如果值不能由单个 UTF-16 代码单元表示，则程序格式不正确。 包含多个字符、转义序列或通用字符名称的 UTF-16 字符文本格式错误。

以 U 前缀开头的字符文本是一个32字符文本。 包含一个字符、转义序列或通用字符名称的 UTF-32 字符文本的值的值等于其 ISO 10646 代码点值。 包含多个字符、转义序列或通用字符名称的32字符串格式不正确。

### 用户定义的文本

## 基本概念

## 内置类型

内置类型（也称为基本类型）由Alolang语言标准指定，并内置于编译器。 不会在任何标头文件中定义内置类型。

AloLang的所有类型和函数的默认链接性为内部链接，意为只在定义的文件内可见

Alolang的内置类型包括如下所有类型及其引用

使用cv标识符表示变量存储特征

函数本身也被认为是一类类型

### 基本数据类型

|名称        |关键字  |说明                |
|-----------|-------|--------------------|
|字符        |char  |应支持所有Unicode字符  |
|整数        |int   |64位整型              |
|高精整数    |long  |无限精度整数           |
|双精度浮点数 |double|                     |
|实数        |real  |可表示所有分数    待定 |
|布尔值      |bool  |                     |

### 复合数据类型

|名称        |关键字  |说明                              |
|-----------|-------|----------------------------------|
|字符串      |string |要求同char                         |
|数组        |array  |一组相同类型的数据，可嵌套，定长       |
|变长数组    |vlarray|可变长度数组                        |
|栈         |stack  |FILO数据组合                        |
|队列        |queue  |FIFO数据组合                       |
|链表        |list   |同STL的list                        |
|元组        |tuple  |由固定个数不一定相同类型的数据组成的结构|
|对          |pair   |成员数量限制为2的tuple              |
|复数        |complex|由两个real或double组成的结构，表示复数|
|四元数      |quaternion|类似complex实现的四元数          |
|矩阵        |mat    |由double组成的矩阵，支持矩阵运算      |
|向量        |vector |数学向量，使用double存储，支持向量运算 |

## 声明和定义以及赋值

任何变量和函数都必须在出现之前进行声明，并在实际使用之前进行定义。

变量和函数在一个文件内仅能进行一次声明和一次定义。

变量声明语句如下：

``` alolang
[extern] [cv] type_name variant_name;
```

变量定义语句如下：

``` alolang
variant_name = value;
```

变量的声明和定义也可在同一行内完成：

``` alolang
[extern] [cv] type_name variant_name = value;
```

非函数的非const变量也可重复赋值，与定义语句形式相同

## 编译器预处理指令

实际编译之前编译器预处理器会对代码进行预处理。使用编译器预处理指令指明要进行的处理

编译器预处理指令每条指令独占一行，以`%`开头。结尾没有分号，没有缩进

以`%`开头的行是且仅是预处理器指令

预处理器指令与参数之间有且只有一个空格。行尾没有空格

预处理指令及其含义如下：

### `%def`

定义编译器预处理常量

实现为宏替换

不支持定义宏函数

用法：

``` alolang
%def NAME VALUE
```

也可定义没有值的常量

``` alolang
%def NAME
```

### `%ifndef`以及`%ifdef`

### `%endif`

### `%rmdef`

### `%lib`

说明库名称，无实际作用

### `%import`

导入AloLang库文件

用法：

``` alolang
%import path_to_lib
```

预处理时实际采用库文件的内容替换该行指令

## 内置运算符、优先级和关联性

### 内置运算符的优先级和关联性同C

### 加法运算符：`+` 和 `-`

相加运算符采用算术或指针类型的操作数。 加法（ `+` ）运算符的结果是操作数之和。 减法（ `-` ）运算符的结果是操作数之差。

### 赋值运算符

简单赋值 `=` 表示将右边的值赋给左边。

复合赋值  `*=`   `/=`   `%=`   `+=`   `-=`   `<<=`   `>>=`   `&=`   `^=`   `|=`  表示将左值与右值进行运算并将结果赋给左边。

赋值运算符返回右值。

### 逻辑 AND 运算符： `&&`

如果两个操作数都为 TRUE，则逻辑 "与" 运算符（ `&&` ）返回布尔值 `true`，否则返回 `false`。 操作数在计算前隐式转换为bool类型，结果为bool类型。

### 逻辑 OR 运算符：`||`

如果两个操作数都为 TRUE，则逻辑 OR 运算符（ `||` ）返回布尔值 `true`，否则返回 `false`。 操作数在计算前隐式转换为bool类型，结果为bool类型。

### 逻辑非运算符：`!`

逻辑求反运算符（ `!` ）反转操作数的含义。 操作数必须是算法或指针类型（或计算结果为算法或指针类型的表达式）。 操作数隐式转换为bool类型。 如果转换后的操作数为 FALSE，则结果为 TRUE;如果转换后的操作数为 TRUE，则结果为 FALSE。 结果的类型为bool。

### 位运算符 `^`  `|`  `&`

分别表示按位异或，按位或，按位与。

两边操作数将被逐位实施异或，或，与。

### 相等运算符 `==`  `!=`

 `==` 左右若相等，返回`true`,反之返回`false`。!=正好相反。

### 关系运算符： `<`、`>`、`<=` 和 `>=`

若所描述的数学命题为真，返回`true`,反之返回`false`。

### 逗号运算符

从左到右依次计算每个表达式，返回一个元组。

### 左移和右移运算符 ( `<<` 和 `>>` )

运算符左边的数每一个位都向指定方向移动指定位。空位填充0。出界位消失。

## 表达式

表达式是用于实现以下一个或多个目的而使用的运算符和操作数的序列：

-计算来自操作数的值。
-指定对象或函数。
-生成“副作用”。 （副作用是表达式的计算之外的所有操作 - 例如，修改对象的值。）

表达式根据其运算符的优先级和分组来计算。

## 语句

Alolang 语句将按顺序执行，除非表达式语句、选择语句、迭代语句或跳转语句特意修改了顺序。

### 标记语句

标签用于将程序控制权直接转交给特定语句。标记语句使用冒号将某种标签与语句隔开。这种标签满足标识符的要求。

只有goto语句可以将程序转到标签处运行。而这是不推荐使用的。

标签具有函数范围，并且不能在函数中重新声明。 但是，相同的名称可用作不同函数中的标签。

### 表达式语句

表达式语句导致计算表达式。 出于表达式语句的原因，不会发生控制或迭代的传输。

表达式语句的语法就是

`[expression ] ;`

在执行下一个语句前，将计算表达式语句中的所有表达式并完成所有副作用。 最常用的表达式语句是赋值和函数调用。 由于表达式是可选的，因此分号单独被视为空的表达式语句，称为null语句。

### 复合语句

复合语句由零个或多个括在大括号（ `{}` ）中的语句组成。 可以在任何期望语句出现的位置使用复合语句。

在Alolang中，也可以使用这样的语法

```Alolang
begin [descriptions]:
[statement list]
end [descriptions];
```
其中description是对内容的描述，没有作用，是可选的。但是上下两处必须相同。

### 选择语句

#### if-else 语句

```Alolang
if ( expression )
{
   statement1;
   ...
}
else  // optional
{
   statement2;
   ...
}
```

表示如果expression为真，则执行statement1...而不执行statement2...。否则执行statement2...，而不执行statement1...。

#### switch语句

```Alolang
switch ( init; expression )
   case constant-expression : statement
   [default  : statement]
```

表示若expression的值等于constant-expression，则跳转到这行执行。若不等于任何一个，则跳转到default执行。

### 迭代语句

#### While 语句

```Alolang
while ( expression )
   statement
```

表示重复执行语句，直到expression的计算结果为零。

表达式的测试在每次执行循环之前发生;因此， while循环将执行零次或多次。 表达式的类型必须可以明确转换为整型。

#### do-while 语句

```Alolang
do
   statement
while ( expression ) ;
```

表示重复执行语句，直到expression的计算结果为零。

终止条件的测试在每次执行循环之后进行;因此， do循环会执行一次或多次，具体取决于终止表达式的值。表达式的类型必须可以明确转换为整型。

#### for语句

```Alolang
for ( init-expression ; cond-expression ; loop-expression )
    statement;
```

重复执行语句，直到条件变为 false。 

### 跳转语句

####　break 语句

`break;`

用于结束执行最近的封闭循环或它所在的条件语句。 控制权将传递给该语句结束之后的语句（如果有的话）。

#### continue语句

`continue;`

强制将控制传输到最小封闭do、 for或while循环的控制表达式。

#### return 语句 

`return [expression];`

终止函数的执行并返回对调用函数的控制（或对操作系统的控制，如果您从 main 函数转移控制）。 紧接在调用之后在调用函数中恢复执行。

#### goto语句

`goto identifier;`

Goto语句无条件将控制转移到由指定的标识符标记的语句。

<!--# 命名空间-->

## 枚举

枚举是用户定义的类型，其中包含一组称为枚举器的命名的整型常数。

## Unions

联合是用户定义的类型，其中的所有成员共享相同的内存位置。 这意味着在任何给定时间，联合都不能包含来自其成员列表的多个对象。 这还意味着无论联合具有多少成员，它始终仅使用足以存储最大成员的内存。

具有大量对象和/或内存有限时，联合可用于节省内存。 但是，需要格外小心才能正确使用它们，因为由你负责确保可始终访问写入的最后一个成员。 如果任何成员类型具有不常用构造函数，则必须编写附加代码来显式构造和销毁该成员。

`union [name]  { member-list };`

## 函数

函数是执行某种操作的代码块。 函数可以选择性地定义使调用方可以将实参传递到函数中的输入形参。 函数可以选择性地返回值作为输出。 函数可用于在单个可重用块中封装常用操作（理想情况是使用可清晰地描述函数行为的名称）。 以下函数接受来自调用方的两个整数并以相反顺序返回它们。

```Alolang
fun foobar(long a, int b) ->int, long 
{
return b,a;
}
```

可以在程序中的任意位置调用或调用函数。 传递给函数的值是参数，其类型必须与函数定义中的参数类型兼容。

对于函数长度没有实际限制，不过良好的设计应以执行单个明确定义的任务的函数为目标。 复杂算法应尽可能分解成易于理解的更简单函数。

最小函数声明包括返回类型、函数名和参数列表（可能为空），以及提供编译器附加说明的可选关键字。 下面的示例是一个函数声明：

```Alolang
fun foobar(long a, int b) ->int, long 
```

函数定义包含声明和主体，主体是大括号之间的所有代码：

```Alolang
fun foobar(long a, int b) ->int, long 
{
return b,a;
}
```
后接分号的函数声明可以出现在程序中的多个位置处。 它必须在每个翻译单元中对该函数的任何调用之前出现。 根据单个定义规则 (ODR)，函数定义必须仅在程序中出现一次。

函数声明的必需部分有：

返回类型，该类型指定函数返回的值的类型; 如果没有返回值，则为`void` 。 

函数名，必须以字母或下划线开头，不能包含空格。 一般而言，标准库函数名中的前导下划线指示私有成员函数，或不是供你的代码使用的非成员函数。

参数列表（一组用大括号限定、逗号分隔的零个或多个参数），指定类型以及可以用于在函数体内访问值的可选局部变量名。

函数声明的可选部分有：

`constexpr`，指示函数的返回值是常量值，可以在编译时进行计算。

```Alolang
constexpr fun exp(float x, int n) ->float
{
    return n == 0 ? 1 :
        n % 2 == 0 ? exp(x * x, n / 2) :
        exp(x * x, (n - 1) / 2) * x;
};
```

链接规范： extern或静态。

```Alolang
//Declare printf with C linkage.
extern fun foobar(long a, int b) ->int, long 
```

inline，指示编译器将对函数的每个调用替换为函数代码本身。 在某个函数快速执行并且在性能关键代码段中重复调用的情况下，内联可以帮助提高性能。

```Alolang
inline fun foobar(long a, int b) ->int, long 
{
return b,a;
}
```

一个` noexcept `表达式，指定函数是否会引发异常。 在下面的示例中，如果 is_pod 表达式的计算结果为true，则函数不引发异常。

```Alolang

#include <type_traits>

template <typename T>
fun copy_object(T& obj) noexcept(std::is_pod<T>) ->T
{...}
```

（仅限成员函数）Cv 限定符，用于指定函数是const函数还是volatile函数。

（仅限成员函数）虚拟、override或 final。 virtual指定可以在派生类中重写函数。 override 表示派生类中的函数在重写虚函数。 final 表示函数不能在任何进一步的派生类中进行重写。

（仅限成员函数）应用于成员函数的静态意味着该函数不与类的任何对象实例相关联。

（仅限非静态成员函数）引用限定符，用于指定编译器在隐式对象参数是右值引用与左值引用时，要选择的函数的重载。

## 运算符重载

运算符关键字声明一个函数，该函数指定应用于类的实例时的运算符。 这将为运算符提供多个含义，或者将“重载”它。 编译器通过检查其操作数类型来区分运算符不同的含义。

以下规则约束如何实现重载运算符。 但是，它们不适用于新的和删除的操作员，它们分别涉及到：

-不能定义新运算符
-将运算符应用于内置数据类型时，不能重新定义其含义。
-重载运算符必须是非静态类成员函数或全局函数。 需要访问私有或受保护的类成员的全局函数必须声明为该类的友元。 全局函数必须至少采用一个类类型或枚举类型的自变量，或者作为对类类型或枚举类型的引用的自变量。 
-运算符遵循它们通常用于内置类型时指定的操作数的优先级、分组和数量。
-声明为成员函数的一元运算符将不采用自变量；如果声明为全局函数，它们将采用一个自变量。
-声明为成员函数的二元运算符将采用一个自变量；如果声明为全局函数，它们将采用两个自变量。
-如果运算符可用作一元运算符或二元运算符（ & 、 * 、 + 和 - ），则可以单独重载每个使用。
-重载运算符不能具有默认自变量。
-派生类继承除赋值（operator = ）以外的所有重载运算符。
-成员函数重载运算符的第一个自变量始终属于针对其调用运算符的对象的类类型（从中声明运算符的类或派生自该类的类）。 没有为第一个参数提供转换。

## 结构体

## 引用

## 异常处理

## 断言和用户提供的消息

